// Narrows down the genus of a 3 regular graph given its adjacency list.
// Prints the maximum cycle fitting as evidence. A fitting is a set of simple
// cycles (length greater than 2) that use each directed edge exactly once.
// These are the faces in Euler's formula: F - E + V = 2 - 2g. Run with `make
// run`

#include <inttypes.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// configuration options:
#define PRINT_PROGRESS true  // whether to print progress messages
#define DEBUG false          // whether to print debug messages

// generated by generate.ipynb:
#define ADJACENCY_LIST_FILENAME "adjacency_list.txt"
#define CYCLES_FILENAME "cycles.txt"
#define CYCLES_BY_VERTEX_FILENAME "cycles_by_vertex.txt"

// assumptions of the program (don't change these):
#define VERTEX_DEGREE 3
#define VERTEX_USE_LIMIT VERTEX_DEGREE
#define MAX_VERTICES 65535
#define MAX_EDGES 65535
#define MAX_CYCLE_LENGTH 65535
#define MAX_CYCLES 4294967295

// consequences of assumptions:
typedef uint8_t degree_t;
#define PRIdegree_t PRIu8
typedef uint16_t vertex_t;
#define PRIvertex_t PRIu16
#define SCNvertex_t SCNu16
typedef uint16_t edge_t;
#define PRIedge_t PRIu16
#define SCNedge_t SCNu16
typedef vertex_t cycle_length_t;  // max length should always be max vertices
#define PRIcycle_length_t PRIvertex_t
#define SCNcycle_length_t SCNvertex_t
typedef uint32_t cycle_index_t;
#define PRIcycle_index_t PRIu32
#define SCNcycle_index_t SCNu32
typedef vertex_t* adj_t;
typedef vertex_t* cycles_t;
typedef cycle_index_t* cbv_t;

// macros
#define assert(condition, message, ...)      \
  if (!(condition)) {                        \
    fprintf(stderr, message, ##__VA_ARGS__); \
    exit(1);                                 \
  }

adj_t adj_load(char* filename, vertex_t* num_vertices, edge_t* num_edges);
vertex_t* adj_get_neighbors(adj_t adjacency_list, vertex_t vertex);
void adj_remove_edge(adj_t adjacency_list, vertex_t start_vertex,
                     vertex_t end_vertex);
void adj_undo_remove_edge(adj_t adjacency_list, vertex_t start_vertex,
                          vertex_t end_vertex);
bool adj_has_edge(adj_t adjacency_list, vertex_t start_vertex,
                  vertex_t end_vertex);

cycles_t cycle_load(char* filename, cycle_length_t* cycle_length,
                    cycle_index_t* num_cycles);
vertex_t* cycle_get(cycles_t cycles, cycle_length_t cycle_length,
                    cycle_index_t cycle_index);

cycle_index_t* cbv_load(char* filename, vertex_t num_vertices, cycles_t cycles,
                        cycle_length_t cycle_length,
                        cycle_index_t* max_cycles_per_vertex);
cycle_index_t* cbv_get_cycle_indices(cbv_t cycles_by_vertex,
                                     cycle_index_t max_cycles_per_vertex,
                                     vertex_t vertex,
                                     cycle_index_t* num_cycles);

void show_progress(double fraction);

bool is_ijk_good(bool* used_cycles, cycles_t cycles,
                 cycle_length_t cycle_length, cycle_index_t num_cycles,
                 cycle_index_t cycle_to_check);
bool search(cycle_index_t cycles_to_use, bool* used_cycles,  // state
            degree_t* vertex_uses, cycle_index_t* max_fit,   // state
            uint64_t* num_search_calls,                      // state
            vertex_t num_vertices, edge_t num_edges, adj_t adjacency_list,
            cycle_length_t cycle_length, cycle_index_t num_cycles,
            cycles_t cycles, cycle_index_t max_cycles_per_vertex,
            cbv_t cycles_by_vertex);

int main(void) {
  if (PRINT_PROGRESS) {
    fprintf(stderr, "Loading data...\n");
  }

  vertex_t num_vertices;
  edge_t num_edges;
  adj_t adjacency_list =
      adj_load(ADJACENCY_LIST_FILENAME, &num_vertices, &num_edges);

  cycle_length_t cycle_length;
  cycle_index_t num_cycles;
  cycles_t cycles = cycle_load(CYCLES_FILENAME, &cycle_length, &num_cycles);

  assert(cycle_length <= num_vertices,
         "Cycle length (%" PRIcycle_length_t
         ") must be less than or equal to the number of "
         "vertices (%" PRIvertex_t ")\n",
         cycle_length, num_vertices);

  cycle_index_t max_cycles_per_vertex;
  cbv_t cycles_by_vertex =
      cbv_load(CYCLES_BY_VERTEX_FILENAME, num_vertices, cycles, cycle_length,
               &max_cycles_per_vertex);

  if (PRINT_PROGRESS) {
    fprintf(stderr, "Starting search...\n");
  }
  show_progress(0.0);

  // keep track of used cycles and vertices
  cycle_index_t cycles_to_use = 2 * num_edges / cycle_length;
  bool* used_cycles = (bool*)malloc(num_cycles * sizeof(bool));
  assert(used_cycles != NULL, "Error allocating memory for the used cycles\n");
  for (cycle_index_t i = 0; i < num_cycles; i++) {
    used_cycles[i] = false;
  }
  // vertices should be used exactly VERTEX_USE_LIMIT times
  // so we keep track of the number of times each vertex has been used.
  // this allows us to fail early if a vertex can't be used enough times
  // and to prioritize vertices exploring vertices that have been used more
  // since they constrain the number of possible cycles containing them more
  degree_t* vertex_uses = (degree_t*)malloc(num_vertices * sizeof(degree_t));
  assert(vertex_uses != NULL,
         "Error allocating memory for the vertices most used order\n");

  // search for a solution that starts with one of the cycles in this work part
  cycle_index_t max_fit = 0;
  uint64_t num_search_calls = 0;
  for (cycle_index_t c = 0; c < num_cycles; c++) {
    if (DEBUG) fprintf(stderr, "\nTrying cycle %d\n", c);

    // default all vertices to 0 uses
    for (vertex_t i = 0; i < num_vertices; i++) {
      vertex_uses[i] = 0;
    }

    // mark start cycle as used
    used_cycles[c] = true;
    cycles_to_use--;
    cycles_t cycle = cycle_get(cycles, cycle_length, c);
    for (cycle_length_t i = 0; i < cycle_length; i++) {
      adj_remove_edge(adjacency_list, cycle[i], cycle[i + 1]);

      // mark cycle vertices as used once
      vertex_uses[cycle[i]] = 1;
    }

    if (search(cycles_to_use, used_cycles, vertex_uses, &max_fit,
               &num_search_calls, num_vertices, num_edges, adjacency_list,
               cycle_length, num_cycles, cycles, max_cycles_per_vertex,
               cycles_by_vertex)) {
      // Success!
      show_progress(1.0);
      if (PRINT_PROGRESS) {
        fprintf(stderr, "\nFound a solution! Check the output to see it.\n");
      }
      printf("Solution found in %" PRId64 " iterations:\n", num_search_calls);
      for (cycle_index_t i = 0; i < num_cycles; i++) {
        if (used_cycles[i]) {
          cycles_t cycle = cycle_get(cycles, cycle_length, i);
          for (cycle_length_t j = 0; j < cycle_length + 1; j++) {
            printf("%" PRIvertex_t " ", cycle[j]);
          }
          printf("\n");
        }
      }
      free(adjacency_list);
      free(cycles);
      free(cycles_by_vertex);
      free(used_cycles);
      free(vertex_uses);
      return 0;
    }

    // mark start cycle as unused
    cycles_to_use++;
    used_cycles[c] = false;
    for (cycle_length_t i = 0; i < cycle_length; i++) {
      adj_undo_remove_edge(adjacency_list, cycle[i], cycle[i + 1]);
    }

    show_progress(c / (double)num_cycles);
  }

  show_progress(1.0);
  if (PRINT_PROGRESS) {
    fprintf(stderr,
            "\nDone. Did not find any solutions. Was only able to fit "
            "%" PRIcycle_index_t " cycles. Used %" PRId64 " iterations.\n",
            max_fit, num_search_calls);
  }
  free(adjacency_list);
  free(cycles);
  free(cycles_by_vertex);
  free(used_cycles);
  free(vertex_uses);
  return 0;
}

void show_progress(double fraction) {
  // E.g. [##########          ] 50%

  if (!PRINT_PROGRESS) {
    return;
  }

  fflush(stderr);
  fprintf(stderr, "\r[");
  for (int i = 0; i < 50; i++) {
    if (i < fraction * 50) {
      fprintf(stderr, "#");
    } else {
      fprintf(stderr, " ");
    }
  }
  fprintf(stderr, "] %d%%", (int)(fraction * 100));
}

// if sequence i -> j -> k occurs in any of the used cycles such that k -> j ->
// i occurs in the cycle_to_check return false
// if no such sequence occurs return true
bool is_ijk_good(bool* used_cycles, cycles_t cycles,
                 cycle_length_t cycle_length, cycle_index_t num_cycles,
                 cycle_index_t cycle_to_check) {
  vertex_t* cycle = cycle_get(cycles, cycle_length, cycle_to_check);

  vertex_t* padded_cycle =
      (vertex_t*)malloc((cycle_length + 2) * sizeof(vertex_t));
  assert(padded_cycle != NULL,
         "Error allocating memory for the padded cycle\n");
  for (cycle_length_t i = 0; i < cycle_length; i++) {
    padded_cycle[i] = cycle[i];
  }
  padded_cycle[cycle_length] = cycle[0];
  padded_cycle[cycle_length + 1] = cycle[1];

  for (cycle_index_t c = 0; c < num_cycles; c++) {
    if (used_cycles[c]) {
      vertex_t* other_cycle = cycle_get(cycles, cycle_length, c);

      vertex_t* padded_other_cycle =
          (vertex_t*)malloc((cycle_length + 2) * sizeof(vertex_t));
      assert(padded_other_cycle != NULL,
             "Error allocating memory for the padded other cycle\n");
      for (cycle_length_t i = 0; i < cycle_length; i++) {
        padded_other_cycle[i] = other_cycle[i];
      }
      padded_other_cycle[cycle_length] = other_cycle[0];
      padded_other_cycle[cycle_length + 1] = other_cycle[1];

      for (cycle_length_t i = 0; i < cycle_length; i++) {
        for (cycle_length_t j = 0; j < cycle_length; j++) {
          if (padded_cycle[i] == padded_other_cycle[j + 2] &&
              padded_cycle[i + 1] == padded_other_cycle[j + 1] &&
              padded_cycle[i + 2] == padded_other_cycle[j]) {
            free(padded_cycle);
            free(padded_other_cycle);
            return false;
          }
        }
      }

      free(padded_other_cycle);
    }
  }

  free(padded_cycle);
  return true;
}

bool search(cycle_index_t cycles_to_use, bool* used_cycles,  // state
            degree_t* vertex_uses, cycle_index_t* max_fit,   // state
            uint64_t* num_search_calls,                      // state
            vertex_t num_vertices, edge_t num_edges, adj_t adjacency_list,
            cycle_length_t cycle_length, cycle_index_t num_cycles,
            cycles_t cycles, cycle_index_t max_cycles_per_vertex,
            cbv_t cycles_by_vertex) {
  (*num_search_calls)++;

  // pick a vertex to explore
  // we pick the most used vertex that hasn't reached the limit since it
  // constrains the search space of possible cycles more
  vertex_t vertex = 0;
  degree_t max_uses = 0;
  for (vertex_t i = 0; i < num_vertices; i++) {
    if (vertex_uses[i] < VERTEX_USE_LIMIT && vertex_uses[i] > max_uses) {
      vertex = i;
      max_uses = vertex_uses[i];

      if (max_uses == VERTEX_USE_LIMIT - 1) {
        break;  // we can't do better than this
      }
    }
  }
  // if we've explored all vertices fully, this cannot be extended further
  if (max_uses == VERTEX_USE_LIMIT) {
    return false;
  }

  // if we've reached a new maximum fit, print it
  if (2 * num_edges / cycle_length - cycles_to_use > *max_fit) {
    *max_fit = 2 * num_edges / cycle_length - cycles_to_use;
    printf("New max fit: %" PRIcycle_index_t
           " (about to try vertex %" PRIvertex_t ")\n",
           *max_fit, vertex);
    for (cycle_index_t i = 0; i < num_cycles; i++) {
      if (used_cycles[i]) {
        vertex_t* cycle = cycle_get(cycles, cycle_length, i);
        for (cycle_length_t j = 0; j < cycle_length + 1; j++) {
          printf("%" PRIvertex_t " ", cycle[j]);
        }
        printf("\n");
      }
    }
    printf("\n");
  }

  // look through the possible cycles that contain this vertex
  // if none can be used, this is a failed end and we backtrack
  // otherwise, we have our solution
  cycle_index_t num_cycles_for_vertex;
  cbv_t cycle_indices = cbv_get_cycle_indices(
      cycles_by_vertex, max_cycles_per_vertex, vertex, &num_cycles_for_vertex);
  for (cycle_index_t i = 0; i < num_cycles_for_vertex; i++) {
    // skip if the cycle is already used
    cycle_index_t cycle_index = cycle_indices[i];
    if (used_cycles[cycle_index]) {
      continue;
    }

    vertex_t* cycle = cycle_get(cycles, cycle_length, cycle_index);

    // cycle is only usable if all edges are available
    bool can_use = true;
    for (cycle_length_t j = 0; j < cycle_length; j++) {
      if (!adj_has_edge(adjacency_list, cycle[j], cycle[j + 1])) {
        can_use = false;
        break;
      }
    }
    if (!can_use) {
      continue;
    }

    // make sure the cycle satisfies the ijk condition
    if (!is_ijk_good(used_cycles, cycles, cycle_length, num_cycles,
                     cycle_index)) {
      continue;
    }

    // use the cycle
    if (DEBUG)
      fprintf(stderr, "Using cycle %" PRIcycle_index_t "\n", cycle_index);
    used_cycles[cycle_index] = true;
    for (cycle_length_t j = 0; j < cycle_length; j++) {
      adj_remove_edge(adjacency_list, cycle[j], cycle[j + 1]);

      // mark cycle vertices as used
      vertex_uses[cycle[j]]++;
      assert(vertex_uses[cycle[j]] <= VERTEX_USE_LIMIT,
             "Vertex %" PRIvertex_t " used too many times\n", cycle[j]);
    }

    // if this is the final cycle needed to cover all edges, we're done
    if (cycles_to_use == 1) {
      return true;
    }
    // otherwise, continue adding cycles
    if (search(cycles_to_use - 1, used_cycles, vertex_uses, max_fit,
               num_search_calls, num_vertices, num_edges, adjacency_list,
               cycle_length, num_cycles, cycles, max_cycles_per_vertex,
               cycles_by_vertex)) {
      return true;  // as soon as we succeed, we're done
    }

    // un-use the cycle
    used_cycles[cycle_index] = false;
    for (uint8_t j = 0; j < cycle_length; j++) {
      adj_undo_remove_edge(adjacency_list, cycle[j], cycle[j + 1]);

      // un-use the cycle vertices
      vertex_uses[cycle[j]]--;
    }
  }

  // if we haven't returned true by now, we've failed
  return false;
}

adj_t adj_load(char* filename, vertex_t* num_vertices, edge_t* num_edges) {
  FILE* fp = fopen(filename, "r");
  assert(fp != NULL, "Error opening file %s\n", filename);

  // number of vertices and edges are the two first numbers
  if (fscanf(fp, "%" SCNvertex_t " %" SCNedge_t "", num_vertices, num_edges) !=
      2) {
    fprintf(stderr, "Error reading the first line of %s\n", filename);
    exit(1);
  }

  adj_t adjacency_list =
      (adj_t)malloc(*num_vertices * VERTEX_DEGREE * sizeof(vertex_t));
  if (adjacency_list == NULL) {
    fprintf(stderr, "Error allocating memory for the adjacency list\n");
    exit(1);
  }
  for (vertex_t i = 0; i < *num_vertices * VERTEX_DEGREE; i++) {
    if (fscanf(fp, "%" SCNvertex_t, &adjacency_list[i]) != 1) {
      fprintf(stderr, "Error reading the adjacency list from %s\n", filename);
      exit(1);
    }
  }

  fclose(fp);

  if (PRINT_PROGRESS) {
    fprintf(stderr, "Read the adjacency list from %s\n",
            ADJACENCY_LIST_FILENAME);
    fprintf(stderr, "\tNumber of vertices: %" PRIvertex_t " \n", *num_vertices);
    fprintf(stderr,
            "\tNumber of edges: %" PRIedge_t " (%" PRIedge_t " directed)\n",
            *num_edges, 2 * *num_edges);
    fprintf(stderr, "\tFirst 5 vertices (with neighbors): ");
    for (vertex_t v = 0; v < 5; v++) {
      fprintf(stderr,
              "%" PRIvertex_t "(%" PRIvertex_t " %" PRIvertex_t " %" PRIvertex_t
              ") ",
              v, adj_get_neighbors(adjacency_list, v)[0],
              adj_get_neighbors(adjacency_list, v)[1],
              adj_get_neighbors(adjacency_list, v)[2]);
    }
    fprintf(stderr, "\n");
  }

  return adjacency_list;
}

vertex_t* adj_get_neighbors(adj_t adjacency_list, vertex_t vertex) {
  return &adjacency_list[vertex * VERTEX_DEGREE];
}

void adj_remove_edge(adj_t adjacency_list, vertex_t start_vertex,
                     vertex_t end_vertex) {
  vertex_t* neighbors = adj_get_neighbors(adjacency_list, start_vertex);
  for (degree_t i = 0; i < VERTEX_DEGREE; i++) {
    if (neighbors[i] == end_vertex) {
      neighbors[i] = MAX_VERTICES;
      return;
    }
  }
}

// must have been previously removed, otherwise undefined behavior
void adj_undo_remove_edge(adj_t adjacency_list, vertex_t start_vertex,
                          vertex_t end_vertex) {
  vertex_t* neighbors = adj_get_neighbors(adjacency_list, start_vertex);
  for (degree_t i = 0; i < VERTEX_DEGREE; i++) {
    if (neighbors[i] == MAX_VERTICES) {
      neighbors[i] = end_vertex;
      return;
    }
  }
}

bool adj_has_edge(adj_t adjacency_list, vertex_t start_vertex,
                  vertex_t end_vertex) {
  vertex_t* neighbors = adj_get_neighbors(adjacency_list, start_vertex);
  for (degree_t i = 0; i < VERTEX_DEGREE; i++) {
    if (neighbors[i] == end_vertex) {
      return true;
    }
  }
  return false;
}

cycles_t cycle_load(char* filename, cycle_length_t* cycle_length,
                    cycle_index_t* num_cycles) {
  FILE* fp = fopen(filename, "r");
  if (fp == NULL) {
    fprintf(stderr, "Error opening file %s\n", filename);
    exit(1);
  }

  // cycle length and number of cycles are the two first numbers
  if (fscanf(fp, "%" SCNcycle_length_t " %" SCNcycle_index_t, cycle_length,
             num_cycles) != 2) {
    fprintf(stderr, "Error reading the first line of %s\n", filename);
    exit(1);
  }

  cycles_t cycles =
      (cycles_t)malloc(*num_cycles * (*cycle_length + 1) * sizeof(vertex_t));
  if (cycles == NULL) {
    fprintf(stderr, "Error allocating memory for the cycles\n");
    exit(1);
  }
  for (cycle_index_t i = 0; i < *num_cycles * (*cycle_length + 1); i++) {
    if (fscanf(fp, "%" SCNvertex_t, &cycles[i]) != 1) {
      fprintf(stderr, "Error reading the cycles from %s\n", filename);
      exit(1);
    }
  }

  fclose(fp);

  if (PRINT_PROGRESS) {
    fprintf(stderr, "Read the cycles from %s\n", CYCLES_FILENAME);
    fprintf(stderr, "\tCycle length: %" PRIcycle_length_t "\n", *cycle_length);
    fprintf(stderr, "\tNumber of cycles: %" PRIcycle_index_t "\n", *num_cycles);
    fprintf(stderr, "\tFirst 5 cycles:\n");
    for (uint8_t i = 0; i < 5; i++) {
      fprintf(stderr, "\t\t%d: ", i);
      for (cycle_length_t j = 0; j < *cycle_length + 1; j++) {
        fprintf(stderr, "%02" PRIvertex_t " ",
                cycle_get(cycles, *cycle_length, i)[j]);
      }
      fprintf(stderr, "\n");
    }
  }

  return cycles;
}

vertex_t* cycle_get(cycles_t cycles, cycle_length_t cycle_length,
                    cycle_index_t cycle_index) {
  return &cycles[cycle_index * (cycle_length + 1)];
}

cbv_t cbv_load(char* filename, vertex_t num_vertices, cycles_t cycles,
               cycle_length_t cycle_length,
               cycle_index_t* max_cycles_per_vertex) {
  FILE* fp = fopen(filename, "r");
  if (fp == NULL) {
    fprintf(stderr, "Error opening file %s\n", filename);
    exit(1);
  }

  // max number of cycles per vertex is the first number
  if (fscanf(fp, "%" PRIcycle_index_t, max_cycles_per_vertex) != 1) {
    fprintf(stderr, "Error reading the first line of %s\n", filename);
    exit(1);
  }

  cbv_t cycles_by_vertex = (cbv_t)malloc(
      num_vertices * (*max_cycles_per_vertex + 1) * sizeof(cycle_index_t));
  if (cycles_by_vertex == NULL) {
    fprintf(stderr, "Error allocating memory for the cycles by vertex\n");
    exit(1);
  }
  for (vertex_t i = 0; i < num_vertices; i++) {
    if (fscanf(fp, "%" SCNcycle_index_t,
               &cycles_by_vertex[i * (*max_cycles_per_vertex + 1)]) != 1) {
      fprintf(stderr, "Error reading the number of cycles for vertex from %s\n",
              filename);
      exit(1);
    }
    for (cycle_index_t j = 0;
         j < cycles_by_vertex[i * (*max_cycles_per_vertex + 1)]; j++) {
      if (fscanf(fp, "%" SCNcycle_index_t,
                 &cycles_by_vertex[i * (*max_cycles_per_vertex + 1) + j + 1]) !=
          1) {
        fprintf(stderr, "Error reading the cycles by vertex from %s\n",
                filename);
        exit(1);
      }
    }
  }

  fclose(fp);

  if (PRINT_PROGRESS) {
    fprintf(stderr, "Read the cycles by vertex from %s\n",
            CYCLES_BY_VERTEX_FILENAME);
    fprintf(stderr, "\tMax cycles per vertex: %" PRIcycle_index_t "\n",
            *max_cycles_per_vertex);
    fprintf(stderr, "\tFirst 2 cycles of vertex 0 and 1:\n");
    for (uint8_t i = 0; i < 2; i++) {
      cycle_index_t num_cycles;
      cycle_index_t* cycle_indices = cbv_get_cycle_indices(
          cycles_by_vertex, *max_cycles_per_vertex, i, &num_cycles);
      fprintf(stderr, "\t\t%d:\n", i);
      for (cycle_index_t j = 0; j < num_cycles && j < 2; j++) {
        fprintf(stderr, "\t\t\t%" PRIcycle_index_t " / %" PRIcycle_index_t ": ",
                j, num_cycles);
        for (cycle_length_t h = 0; h < cycle_length + 1; h++) {
          fprintf(stderr, "%02" PRIvertex_t " ",
                  cycle_get(cycles, cycle_length, cycle_indices[j])[h]);
        }
        fprintf(stderr, "\n");
      }
    }
  }

  return cycles_by_vertex;
}

cycle_index_t* cbv_get_cycle_indices(cbv_t cycles_by_vertex,
                                     cycle_index_t max_cycles_per_vertex,
                                     vertex_t vertex,
                                     cycle_index_t* num_cycles) {
  cycle_index_t* row = &cycles_by_vertex[vertex * (max_cycles_per_vertex + 1)];
  *num_cycles = row[0];
  return &row[1];
}
