import sys
import re
import json
from math import dist as calculate_distance  # Requires Python 3.8+
from collections import defaultdict

# Helper for distance calculation if using older Python
# def calculate_distance(p1, p2):
#     return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5


def parse_tikz_graph(tikz_content):
    """
    Parses TikZ content generated by planar_cutthroughedges_draw.c.

    Args:
        tikz_content: A string containing the TikZ code.

    Returns:
        A dictionary containing nodes, edges, and boundary identification pairs,
        or None if parsing fails.
    """

    nodes = (
        {}
    )  # Stores {node_id_str: {"x": float, "y": float, "type": "original|boundary", "label": "str"}}
    edges = []  # Stores {"u": node_id_str, "v": node_id_str}
    boundary_segments = []  # Temp storage for parsed boundary arc info
    temp_tkz_points = {}  # Stores coords for A, B, C used by tkzDrawArc

    # --- Regex Patterns (Adjusted for the example format) ---

    # Matches \node [...] (id) at (x,y) {label}; or \node [...] (id) at (x,y) {};
    # Captures: style_content, node_id, x, y, label (optional)
    node_pattern = re.compile(
        r"\\node.*?\[(.*?)\]\s*\((\d+)\)\s*at\s*\(\s*([-\d.]+)\s*,\s*([-\d.]+)\s*\)\s*\{(.*?)\};"
    )

    # Matches \tkzDefPoint(x,y){id} - Captures x, y, node_id (A, B, C, or number)
    tkzdefpoint_pattern = re.compile(
        r"\\tkzDefPoint\(\s*([-\d.]+)\s*,\s*([-\d.]+)\s*\)\s*\{(\w+)\}"
    )

    # Matches \draw [black] (u) to (v); - Captures u, v
    edge_pattern = re.compile(r"\\draw\s*\[black\]\s*\((\d+)\)\s*to\s*\((\d+)\);")

    # Matches \tkzDrawArc[style](Center,End)(Start) - Captures style, center_id, end_id, start_id
    boundary_arc_pattern = re.compile(
        r"\\tkzDrawArc\[(.*?)\]\s*\(\s*(\w+)\s*,\s*(\w+)\s*\)\s*\(\s*(\w+)\s*\)"
    )

    # Matches \node [draw=none,fill=none,scale=\labelscale] () at (x,y) {label}; - Captures x, y, label
    boundary_label_pattern = re.compile(
        r"\\node.*?\[draw=none,fill=none,scale=\\labelscale\]\s*\(\)\s*at\s*\(\s*([-\d.]+)\s*,\s*([-\d.]+)\s*\)\s*\{(\d+)\};"
    )

    # --- Parsing Logic ---
    lines = tikz_content.splitlines()

    for line in lines:
        line = line.strip()
        if not line or line.startswith("%"):
            continue

        # Match tkzDefPoint (stores A, B, C for arcs AND defines numbered boundary nodes)
        tkz_match = tkzdefpoint_pattern.search(line)
        if tkz_match:
            x, y, point_id = tkz_match.groups()
            coords = (float(x), float(y))
            temp_tkz_points[point_id] = coords
            # If the ID is numeric, it's a boundary node definition
            if point_id.isdigit():
                nodes[point_id] = {
                    "x": coords[0],
                    "y": coords[1],
                    "type": "boundary",
                    "label": point_id,  # Label is the ID itself
                }
            continue  # Process next line

        # Match \node [scale=\labelscale] (labels which vertex each connected boundary node stands for)
        bnd_label_match = boundary_label_pattern.search(line)
        if bnd_label_match:
            x, y, label = bnd_label_match.groups()
            coord = (float(x), float(y))
            boundary_node_ids = [
                nid for nid, data in nodes.items() if data["type"] == "boundary"
            ]
            bnd_id = min(
                boundary_node_ids,
                key=lambda nid: calculate_distance(
                    coord, (nodes[nid]["x"], nodes[nid]["y"])
                ),
            )
            nodes[bnd_id]["for"] = label

        # Match \node (defines original nodes AND styles boundary nodes)
        node_match = node_pattern.search(line)
        if node_match:
            style, node_id, x, y, label = node_match.groups()
            node_type = "original" if label.strip() else "boundary_styled"
            # Only add if not already defined by tkzDefPoint, or update type/label
            if node_id not in nodes:
                nodes[node_id] = {
                    "x": float(x),
                    "y": float(y),
                    "type": node_type,
                    "label": label.strip() or node_id,
                }
            elif node_type == "original":  # Update if this is the main definition
                nodes[node_id]["type"] = "original"
                nodes[node_id]["label"] = label.strip() or node_id
            # We prioritize tkzDefPoint for boundary node coordinates/ID.
            continue

        # Match \draw [black] (original edges)
        edge_match = edge_pattern.search(line)
        if edge_match:
            u, v = edge_match.groups()
            # Ensure nodes exist before adding edge (might parse nodes after edges)
            # If robustness needed, store edges and add after all nodes parsed.
            if u in nodes and v in nodes:
                edges.append({"u": u, "v": v})
            else:
                print(f"Warning: Nodes for edge ({u},{v}) not defined yet.")
            continue

        # Match \tkzDrawArc (boundary segments)
        boundary_match = boundary_arc_pattern.search(line)
        if boundary_match:
            style, center_id, end_id, start_id = boundary_match.groups()

            # Extract color and direction
            color_match = re.search(
                r"\b(red|blue|green|orange|olive|gray|pink|yellow|lime|cyan)\b", style
            )
            color = color_match.group(1) if color_match else None
            arrow_match = re.search(r"(<-|->)", style)
            direction = arrow_match.group(1) if arrow_match else None

            # Get endpoint coordinates from stored A, B points
            start_coords = temp_tkz_points.get(start_id)
            end_coords = temp_tkz_points.get(end_id)

            if not start_coords or not end_coords:
                print(
                    f"Warning: Could not find coordinates for boundary arc points {start_id}/{end_id} in line: {line}"
                )
                continue

            if not color or not direction:
                print(
                    f"Warning: Could not parse color/direction for boundary arc: {line}"
                )
                continue

            # Find the two *numbered boundary node IDs* closest to start_coords and end_coords
            boundary_node_ids = [
                nid for nid, data in nodes.items() if data["type"] == "boundary"
            ]
            if not boundary_node_ids:
                print(
                    f"Warning: No boundary nodes found to map arc endpoints for line: {line}"
                )
                continue

            start_node_id = min(
                boundary_node_ids,
                key=lambda nid: calculate_distance(
                    start_coords, (nodes[nid]["x"], nodes[nid]["y"])
                ),
            )
            end_node_id = min(
                boundary_node_ids,
                key=lambda nid: calculate_distance(
                    end_coords, (nodes[nid]["x"], nodes[nid]["y"])
                ),
            )

            boundary_segments.append(
                {
                    "start_node": start_node_id,
                    "end_node": end_node_id,
                    "color": color,
                    "direction": direction,
                    "line": line,  # Keep original line for debugging
                }
            )
            # Clear A, B, C points as they are usually redefined for the next arc
            temp_tkz_points.pop("A", None)
            temp_tkz_points.pop("B", None)
            temp_tkz_points.pop("C", None)
            continue

    # --- Post-processing: Identify Boundary Pairs ---
    boundary_pairs_dict = defaultdict(lambda: {"->": None, "<-": None})
    unmatched_segments = []

    for seg in boundary_segments:
        key = seg["color"]  # Group by color
        direction = seg["direction"]
        if (
            direction in boundary_pairs_dict[key]
            and boundary_pairs_dict[key][direction] is None
        ):
            boundary_pairs_dict[key][direction] = seg
        else:
            # Handle cases where a color might have >2 segments or multiple of same direction
            print(
                f"Warning: Unexpected segment for color {key}, direction {direction}. Storing as unmatched: {seg['line']}"
            )
            unmatched_segments.append(seg)

    final_boundary_pairs = []
    for color, pair in boundary_pairs_dict.items():
        seg1 = pair.get("->")
        seg2 = pair.get("<-")
        if seg1 and seg2:
            # Store the pair of node segments that should be identified
            # The exact order (u1,v1 vs v1,u1) matters for orientation
            final_boundary_pairs.append(
                {
                    "id": color,
                    "segment1": {
                        "u": seg1["start_node"],
                        "v": seg1["end_node"],
                    },  # Following -> direction
                    "segment2": {
                        "u": seg2["end_node"],
                        "v": seg2["start_node"],
                    },  # Following <- direction (reversed nodes)
                }
            )
        else:
            print(f"Warning: Incomplete pair found for color {color}.")
            if seg1:
                unmatched_segments.append(seg1)
            if seg2:
                unmatched_segments.append(seg2)

    if unmatched_segments:
        print("\nUnmatched boundary segments:")
        for seg in unmatched_segments:
            print(f"  - {seg['line']}")

    # --- Final Output ---
    if not nodes:
        print("Warning: No nodes found in TikZ input.")
        return None

    # Filter out temporary styled boundary nodes if needed
    final_nodes = {
        nid: data for nid, data in nodes.items() if data["type"] != "boundary_styled"
    }

    return {
        "nodes": final_nodes,
        "edges": edges,
        "boundary_pairs": final_boundary_pairs,
    }


# --- Example Usage ---
if __name__ == "__main__":
    tikz = sys.stdin.read()

    # For demonstration, parse the example string
    parsed_data = parse_tikz_graph(tikz)

    if parsed_data:
        print("\n--- Parsed TikZ Data ---")
        print(json.dumps(parsed_data, indent=2))

        # Example: Verify the extracted data
        print(
            f"\nNumber of original nodes found: {len([n for n, d in parsed_data['nodes'].items() if d['type'] == 'original'])}"
        )
        print(
            f"Number of boundary nodes found: {len([n for n, d in parsed_data['nodes'].items() if d['type'] == 'boundary'])}"
        )
        print(f"Number of original edges found: {len(parsed_data['edges'])}")
        print(f"Number of boundary pairs found: {len(parsed_data['boundary_pairs'])}")
        if parsed_data["boundary_pairs"]:
            print("Example Boundary Pair:")
            print(f"  ID: {parsed_data['boundary_pairs'][0]['id']}")
            print(f"  Segment 1: {parsed_data['boundary_pairs'][0]['segment1']}")
            print(f"  Segment 2: {parsed_data['boundary_pairs'][0]['segment2']}")

    else:
        print("\nParsing Failed.")
